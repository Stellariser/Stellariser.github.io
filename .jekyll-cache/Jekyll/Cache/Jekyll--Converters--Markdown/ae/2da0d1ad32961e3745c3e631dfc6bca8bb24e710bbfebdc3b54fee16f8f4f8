I"1[<h1 id="刷题笔记">刷题笔记</h1>

<h2 id="1-相向双指针">1 相向双指针</h2>

<h3 id="两数之和">两数之和</h3>

<p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code class="language-plaintext highlighter-rouge">numbers</code> ，该数组已按 <strong>非递减顺序排列</strong> ，请你从数组中找出满足相加之和等于目标数 <code class="language-plaintext highlighter-rouge">target</code> 的两个数。如果设这两个数分别是 <code class="language-plaintext highlighter-rouge">numbers[index1]</code> 和 <code class="language-plaintext highlighter-rouge">numbers[index2]</code> ，则 <code class="language-plaintext highlighter-rouge">1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p>

<p>以长度为 2 的整数数组 <code class="language-plaintext highlighter-rouge">[index1, index2]</code> 的形式返回这两个整数的下标 <code class="language-plaintext highlighter-rouge">index1</code> 和 <code class="language-plaintext highlighter-rouge">index2</code>。</p>

<p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p>

<p>你所设计的解决方案必须只使用常量级的额外空间。</p>

<p>相向双指针模板题目</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">start</span><span class="p">,</span><span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">start</span><span class="o">&lt;</span><span class="n">end</span><span class="p">:</span>
            <span class="n">htsum</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="o">+</span><span class="n">numbers</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">htsum</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="k">if</span> <span class="n">htsum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">start</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">htsum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">end</span><span class="o">-=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div>

<p>检查双指针的头和尾，如果和大于target，既然是有序的，那么末尾这个加任何一个前面的都大于，那么就尾部减一。如果和小于target，同理，加尾部往前任何一个就会小于，那么就头部指针加一。</p>

<h3 id="三数之和">三数之和</h3>

<p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> ，判断是否存在三元组 <code class="language-plaintext highlighter-rouge">[nums[i], nums[j], nums[k]]</code> 满足 <code class="language-plaintext highlighter-rouge">i != j</code>、<code class="language-plaintext highlighter-rouge">i != k</code> 且 <code class="language-plaintext highlighter-rouge">j != k</code> ，同时还满足 <code class="language-plaintext highlighter-rouge">nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code class="language-plaintext highlighter-rouge">0</code> 且不重复的三元组。</p>

<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>

<p>这道题可以把nums[i] + nums[j] + nums[k] == 0 改为 nums[j] + nums[k] == -nums[i]</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">threeSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">nums</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">res</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>      <span class="c1">#枚举所有可能的i
</span>            <span class="n">ressub</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">x</span><span class="o">==</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>     <span class="c1">#既然加起来是0，那么往后找就行，毕竟是有序的
</span>            <span class="n">k</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">while</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">k</span><span class="p">:</span>
                <span class="n">sm</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sm</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">sm</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">k</span><span class="o">-=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">sm</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
                    <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="k">while</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">k</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1">#去除重复的，很关键，首先多个答案，因此需要把j和k调整，继续遍历
</span>                        <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="n">k</span><span class="o">-=</span><span class="mi">1</span>
                    <span class="k">while</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">k</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1">#如果遇到一样的值，那就跳过
</span>                        <span class="n">k</span><span class="o">-=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<p>底下部分代码是一样的，但是一开始i用一个for循环枚举可能的i</p>

<h3 id="盛水最多的容器">盛水最多的容器</h3>

<p>给定一个长度为 <code class="language-plaintext highlighter-rouge">n</code> 的整数数组 <code class="language-plaintext highlighter-rouge">height</code> 。有 <code class="language-plaintext highlighter-rouge">n</code> 条垂线，第 <code class="language-plaintext highlighter-rouge">i</code> 条线的两个端点是 <code class="language-plaintext highlighter-rouge">(i, 0)</code> 和 <code class="language-plaintext highlighter-rouge">(i, height[i])</code> 。</p>

<p>找出其中的两条线，使得它们与 <code class="language-plaintext highlighter-rouge">x</code> 轴共同构成的容器可以容纳最多的水。</p>

<p>返回容器可以储存的最大水量。</p>

<p><strong>说明：</strong>你不能倾斜容器。</p>

<p><img src="/assets/img/leetcode/image-20240802162006115.png" alt="image-20240802162006115" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">left</span><span class="p">,</span><span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">inf</span>
        <span class="k">while</span> <span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="p">:</span>
            <span class="n">leftbar</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
            <span class="n">rightbar</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            <span class="n">liq</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">leftbar</span><span class="p">,</span><span class="n">rightbar</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">liq</span><span class="o">&gt;</span><span class="n">res</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">liq</span>
            <span class="k">if</span> <span class="n">leftbar</span><span class="o">&lt;=</span><span class="n">rightbar</span><span class="p">:</span>
                <span class="n">left</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">leftbar</span><span class="o">&gt;</span><span class="n">rightbar</span><span class="p">:</span>
                <span class="n">right</span><span class="o">-=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">res</span>

</code></pre></div></div>

<p>同样的，相向双指针，总是移动较短的拿一根的指针，因为如果我们选择了目前较短的那一根，我们移动左侧的指针，如果左侧更短，那么左侧的不但见笑了底，还减小了高，很蠢。如果左侧的更长了，那么有效的高度还是右侧固定的这一根，并且底还变短了，也是没有意义的，因此需要移动较短的那一根。</p>

<h3 id="接雨水">接雨水</h3>

<p>给定 <code class="language-plaintext highlighter-rouge">n</code> 个非负整数表示每个宽度为 <code class="language-plaintext highlighter-rouge">1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>

<p><img src="/assets/img/leetcode/image-20240802172559556.png" alt="image-20240802172559556" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">trap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
        <span class="n">postfix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
        <span class="n">currentheiget</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)):</span>         <span class="c1">#前缀最高
</span>            <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">currentheiget</span><span class="p">:</span>
                <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentheiget</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">currentheiget</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentheiget</span>
        <span class="n">currentheiget</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>      <span class="c1">#后缀最高
</span>            <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">currentheiget</span><span class="p">:</span>
                <span class="n">postfix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentheiget</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">currentheiget</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">postfix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentheiget</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)):</span>            <span class="c1">#计算每一个小桶，小桶的有效高度是两个板子中较低的有效高度减去本身的高度，也就是底的高度
</span>            <span class="n">realh</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">postfix</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">res</span><span class="o">+=</span><span class="n">realh</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<p>我们可以这么思考，当前这个格子看作一个底边长为1的桶，他的左侧板和右侧板为，到目前为止左侧的最高高度和右侧的最高高度，因此使用两个遍历计算出前缀最高和后缀最高，然后一个格子一个格子的计算。</p>

<h2 id="2-滑动窗口">2 滑动窗口</h2>

<h3 id="最长不重复子序列">最长不重复子序列</h3>

<p>给定一个字符串 <code class="language-plaintext highlighter-rouge">s</code> ，请你找出其中不含有重复字符的 最长 子串的长度。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]:</span>
                <span class="n">left</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<p>只能背了</p>

<p>当右侧的已经出现在结果中的时候就从左边开始缩小，反之就继续伸展右侧的。</p>

<h3 id="最短目标子序列">最短目标子序列</h3>

<p>给定一个含有 <code class="language-plaintext highlighter-rouge">n</code> 个正整数的数组和一个正整数 <code class="language-plaintext highlighter-rouge">target</code> <strong>。</strong>找出该数组中满足其总和大于等于 <code class="language-plaintext highlighter-rouge">target</code> 的长度最小的 <strong>子数组</strong><code class="language-plaintext highlighter-rouge">[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code class="language-plaintext highlighter-rouge">0</code> 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minSubArrayLen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">)</span>
        <span class="n">csum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">right</span> <span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">csum</span><span class="o">+=</span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">csum</span><span class="o">&gt;=</span><span class="n">target</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">csum</span><span class="o">-=</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
                <span class="n">left</span><span class="o">+=</span><span class="mi">1</span>
                
            <span class="n">right</span><span class="o">+=</span><span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">res</span> <span class="o">==</span><span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">):</span> 
            <span class="k">return</span> <span class="mi">0</span> 
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h3><img src="/assets/img/leetcode/image-20240802193031463.png" alt="image-20240802193031463" /></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numSubarrayProductLessThanK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">left</span><span class="p">,</span><span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
        <span class="n">currentmul</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">right</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">currentmul</span><span class="o">*=</span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            <span class="n">right</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">while</span> <span class="n">currentmul</span> <span class="o">&gt;=</span><span class="n">k</span> <span class="ow">and</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">currentmul</span><span class="o">/=</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
                <span class="n">left</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">res</span> <span class="o">+=</span><span class="n">right</span><span class="o">-</span><span class="n">left</span>        <span class="c1">#这是很重要的，因为是要计算你所有字串的个数，如果一个串满足，那么其中的right-left个就都满足
</span>        <span class="k">return</span> <span class="n">res</span>

       


</code></pre></div></div>

<p>左右缩放</p>

<h2 id="3-二分查找">3 二分查找</h2>

<p>这是一个边界条件非常严格的专题，有很多种不同的写法，效果都是一样的</p>

<h4 id="三种写法">三种写法</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 闭区间写法
</span><span class="k">def</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># 闭区间 [left, right]
</span>    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>  <span class="c1"># 区间不为空
</span>        <span class="c1"># 循环不变量：
</span>        <span class="c1"># nums[left-1] &lt; target
</span>        <span class="c1"># nums[right+1] &gt;= target
</span>        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 范围缩小到 [mid+1, right]
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># 范围缩小到 [left, mid-1]
</span>    <span class="k">return</span> <span class="n">left</span>

<span class="c1"># 左闭右开区间写法
</span><span class="k">def</span> <span class="nf">lower_bound2</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>  <span class="c1"># 左闭右开区间 [left, right)
</span>    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>  <span class="c1"># 区间不为空
</span>        <span class="c1"># 循环不变量：
</span>        <span class="c1"># nums[left-1] &lt; target
</span>        <span class="c1"># nums[right] &gt;= target
</span>        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 范围缩小到 [mid+1, right)
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span>  <span class="c1"># 范围缩小到 [left, mid)
</span>    <span class="k">return</span> <span class="n">left</span>  <span class="c1"># 返回 left 还是 right 都行，因为循环结束后 left == right
</span>
<span class="c1"># 开区间写法
</span><span class="k">def</span> <span class="nf">lower_bound3</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>  <span class="c1"># 开区间 (left, right)
</span>    <span class="k">while</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>  <span class="c1"># 区间不为空
</span>        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="c1"># 循环不变量：
</span>        <span class="c1"># nums[left] &lt; target
</span>        <span class="c1"># nums[right] &gt;= target
</span>        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span>  <span class="c1"># 范围缩小到 (mid, right)
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span>  <span class="c1"># 范围缩小到 (left, mid)
</span>    <span class="k">return</span> <span class="n">right</span>

</code></pre></div></div>

<p>可以仔细查看它们之间的不同。</p>

<h4 id="在排序数组中查找元素的第一个和最后一个位置">在排序数组中查找元素的第一个和最后一个位置</h4>

<p><img src="/assets/img/leetcode/image-20240803140727687.png" alt="image-20240803140727687" /></p>

<p>解决这个问题</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">searchRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">def</span> <span class="nf">bis</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">target</span><span class="p">):</span>
            <span class="n">left</span><span class="p">,</span><span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">while</span> <span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="p">:</span>
                <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span><span class="o">&lt;</span><span class="n">target</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">left</span>
        
        <span class="n">start</span> <span class="o">=</span> <span class="n">bis</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">target</span><span class="p">)</span>     <span class="c1">#这个办法会找到第一个
</span>        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="ow">or</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">!=</span> <span class="n">target</span><span class="p">:</span> <span class="c1">#这两个判断的顺序不能调换，后面的放到前面就会数组越界
</span>            <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">bis</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>        <span class="c1">#找到比他大1的位置-1就可以找到末尾
</span>        <span class="k">return</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="寻找旋转排序数组中的最小值">寻找旋转排序数组中的最小值</h4>

<p><img src="/assets/img/leetcode/image-20240803153927412.png" alt="image-20240803153927412" /></p>

<p>这里我还是坚持使用闭区间，用中间值和数组最左侧的值进行比较</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="p">:</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">middlenumber</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">middlenumber</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span><span class="n">middle</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
            
        
</code></pre></div></div>

<p>非常帅的题</p>

<h4 id="搜索旋转排序数组">搜索旋转排序数组</h4>

<p><img src="/assets/img/leetcode/image-20240804152924632.png" alt="image-20240804152924632" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">leftside</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1">#最后一个
</span>            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">end</span><span class="p">:</span>   <span class="c1">#中点在左边一段,也就是排序好的一段
</span>                <span class="k">return</span> <span class="n">target</span><span class="o">&gt;</span><span class="n">end</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">target</span>   <span class="c1">#target和他在同一段
</span>            <span class="k">else</span><span class="p">:</span>       <span class="c1">#中点在右边一段
</span>                <span class="k">return</span> <span class="n">target</span><span class="o">&gt;</span><span class="n">end</span> <span class="ow">or</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">target</span>   <span class="c1">#在左边一段高的部分   在左边一段低的部分
</span>
        <span class="n">left</span><span class="p">,</span><span class="n">right</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="p">:</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">leftside</span><span class="p">(</span><span class="n">middle</span><span class="p">):</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="ow">or</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">!=</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left</span>
</code></pre></div></div>

<p>只需要额外设计一个函数，判断因该舍弃哪一部分的数组就可以了</p>

<h2 id="4链表">4.链表</h2>

<h3 id="反转链表">反转链表</h3>

<p><img src="/assets/img/leetcode/image-20240804161228682.png" alt="image-20240804161228682" /></p>

<p>解答</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span><span class="p">:</span>
            <span class="k">return</span>  <span class="bp">None</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
            <span class="n">nextcure</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>   <span class="c1">#先记录后一个节点
</span>            <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span>     <span class="c1">#反转
</span>            <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span>    <span class="c1">#更新前一个
</span>            <span class="n">cur</span> <span class="o">=</span> <span class="n">nextcure</span>     <span class="c1">#更新当前
</span>        <span class="k">return</span> <span class="n">prev</span>
</code></pre></div></div>

<p>一般来说链表题都会有一个当前节点，和前一个结点，然后以当前节点是否为空进行判断</p>

<p>这里要注意记录当前节点的后一个节点，因为反转后原来的下一个节点就无法通过当前节点的next来获取了</p>

<h4 id="反转链表2">反转链表2</h4>

<p><img src="/assets/img/leetcode/image-20240804192500031.png" alt="image-20240804192500031" /></p>

<p>非常恶心人的一道题</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseBetween</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">left</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">dummy</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">left</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c1">#首先找到头节点
</span>            <span class="n">p0</span> <span class="o">=</span> <span class="n">p0</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">p0</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>  <span class="c1">#这边开始反转，要注意，这次cur是第一个，所以prev是None
</span>            <span class="n">nexto</span> <span class="o">=</span><span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">nexto</span>
        <span class="n">p0</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="o">=</span> <span class="n">cur</span>           <span class="c1">#这个时候p0还是指向的后一个，所以next就可以指向被反转序列的最后一个，然后把他指向不需要反转的后一部分
</span>        <span class="n">p0</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span>             <span class="c1">#指向被反转序列的头部
</span>        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>

</code></pre></div></div>

<h4 id="k个一组反转链表">k个一组反转链表</h4>

<p><img src="/assets/img/leetcode/image-20240805161448549.png" alt="image-20240805161448549" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseKGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">counthead</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">counthead</span><span class="p">:</span>
            <span class="n">counthead</span> <span class="o">=</span> <span class="n">counthead</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">dummy</span>
        <span class="k">while</span> <span class="n">count</span><span class="o">&gt;=</span><span class="n">k</span><span class="p">:</span>
            <span class="n">count</span><span class="o">-=</span><span class="n">k</span> 
            <span class="n">prev</span> <span class="o">=</span><span class="bp">None</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">p0</span><span class="p">.</span><span class="nb">next</span>      
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">nextone</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
                <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">nextone</span>
            <span class="n">nextp0</span> <span class="o">=</span> <span class="n">p0</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">p0</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="n">p0</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">nextp0</span>    
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>    
</code></pre></div></div>

<p><img src="/assets/img/leetcode/image-20240805162118986.png" alt="image-20240805162118986" /></p>

<p>做这种题一定要定位p0，cur和prev</p>

<h3 id="链表中的快慢指针">链表中的快慢指针</h3>

<h4 id="链表的中间节点">链表的中间节点</h4>

<p><img src="/assets/img/leetcode/image-20240805163316874.png" alt="image-20240805163316874" /></p>

<p>可以使用一个每次走两步的和一个每次走一步的指针，快的到了，慢的也就正好到了一半，但是边缘条件要处理好</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">middleNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">slowp</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">fastp</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">fastp</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fastp</span><span class="p">.</span><span class="nb">next</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">fastp</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slowp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slowp</span> <span class="o">=</span><span class="n">slowp</span><span class="p">.</span><span class="nb">next</span>
                <span class="n">fastp</span><span class="o">=</span> <span class="n">fastp</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">slowp</span>
</code></pre></div></div>

<h4 id="判断链表是否有环">判断链表是否有环</h4>

<p><img src="/assets/img/leetcode/image-20240805172056758.png" alt="image-20240805172056758" /></p>

<p>用字典记录是一种办法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
                <span class="n">dic</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>         
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

</code></pre></div></div>

<p>还有一种就是也用快慢指针，因为如果有环，那么快指针一定会追上慢指针</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="n">fast</span> <span class="o">==</span> <span class="n">slow</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

</code></pre></div></div>

<h4 id="环形链表2-找到环出现的点">环形链表2 找到环出现的点</h4>

<p><img src="/assets/img/leetcode/image-20240805174125435.png" alt="image-20240805174125435" /></p>

<p>哈希表</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">detectCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
            <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">cur</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
                <span class="n">dic</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cur</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>

<h3 id="链表中的快慢指针-1">链表中的快慢指针</h3>

<h4 id="删除链表的倒数第n个节点">删除链表的倒数第n个节点</h4>

<p><img src="/assets/img/leetcode/image-20240806142011301.png" alt="image-20240806142011301" /></p>

<p>一般来说，当有可能会需要删除头节点的时候，使用dummy节点</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">dummy</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">dummy</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>    <span class="c1">#先走
</span>            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">while</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>        <span class="c1">#快指针到了，我就到了
</span>        <span class="n">slow</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>  <span class="c1">#删除
</span>        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>

<p>快指针先移动n步，然后慢指针开始跑，快指针到头了，慢指针也到了要删除的节点之前了。</p>

<h4 id="删除排序链表中的重复元素">删除排序链表中的重复元素</h4>

<p><img src="/assets/img/leetcode/image-20240806143713938.png" alt="image-20240806143713938" /></p>

<p>如果是排序好的，就可以使用快慢指针。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">vic</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="n">vic</span><span class="p">.</span><span class="n">val</span>  <span class="o">==</span> <span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">vic</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">head</span>

        <span class="c1"># if not head:
</span>        <span class="c1">#     return None
</span>        <span class="c1"># dummy = ListNode()
</span>        <span class="c1"># dummy.next = head
</span>        <span class="c1"># fast = dummy
</span>        <span class="c1"># middle = dummy
</span>        <span class="c1"># tail = dummy
</span>        <span class="c1"># fast = fast.next.next
</span>        <span class="c1"># middle = middle.next
</span>        <span class="c1"># while fast:
</span>        <span class="c1">#     if fast.val == middle.val:
</span>        <span class="c1">#         print("youle")
</span>        <span class="c1">#         tail.next = fast
</span>        <span class="c1">#         middle = fast
</span>        <span class="c1">#         fast = fast.next
</span>        <span class="c1">#     else:    
</span>        <span class="c1">#         fast = fast.next
</span>        <span class="c1">#         middle = middle.next
</span>        <span class="c1">#         tail = tail.next
</span>        <span class="c1"># return dummy.next
</span>        

</code></pre></div></div>

<h4 id="删除列表中重读的元素连带他本身">删除列表中重读的元素,连带他本身</h4>

<p><img src="/assets/img/leetcode/image-20240806160435131.png" alt="image-20240806160435131" /></p>

<p>这个可以先用哈希表做，做出来最重要</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur</span><span class="p">.</span><span class="n">val</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
                <span class="n">dic</span><span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dic</span><span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="n">val</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">dummy</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dic</span><span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">dic</span><span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">])</span>
                <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>

</code></pre></div></div>

<h2 id="5二叉树">5.二叉树</h2>

<h3 id="递归二叉树">递归二叉树</h3>

<h4 id="二叉树的最大深度">二叉树的最大深度</h4>

<p><img src="/assets/img/leetcode/image-20240806164408193.png" alt="image-20240806164408193" /></p>

<p><img src="/assets/img/leetcode/image-20240806164414620.png" alt="image-20240806164414620" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>         <span class="c1">#第一种方法
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>

        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">def</span> <span class="nf">dfs2</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">count</span><span class="p">):</span>       <span class="c1">#第二种方法
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> 
            <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">nonlocal</span> <span class="n">res</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">count</span><span class="p">)</span>
            <span class="n">dfs2</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">count</span><span class="p">)</span>
            <span class="n">dfs2</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">count</span><span class="p">)</span>

        <span class="n">dfs2</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>     
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h4 id="相同的树">相同的树</h4>

<p><img src="/assets/img/leetcode/image-20240806174356505.png" alt="image-20240806174356505" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">q</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">dfs</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">q</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dfs</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">q</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="对称二叉树">对称二叉树</h4>

<p><img src="/assets/img/leetcode/image-20240806175147044.png" alt="image-20240806175147044" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>
        
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">):</span>                 <span class="c1">#传入一个左边的树和右边的树，因为根节点是分界点，所以拆成左右两棵树
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            
            <span class="k">return</span> <span class="n">left</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">right</span><span class="p">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">dfs</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dfs</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">right</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>  <span class="c1">#递归左边的左子树和右边的右子树，左边的右子树和右边的左子树，判断他们是否一样呢
</span>        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="平衡二叉树">平衡二叉树</h4>

<p><img src="/assets/img/leetcode/image-20240806181418663.png" alt="image-20240806181418663" /></p>

<p>非常好的一道题</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isBalanced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>         <span class="c1">#如果有-1，那就一直返回
</span>                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>   <span class="c1">#这边也是一样 
</span>            <span class="k">if</span> <span class="n">right</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">left</span><span class="o">-</span><span class="n">right</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>      <span class="c1">#但是加一个条件，就是不平衡的时候也返回-1
</span>                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>        <span class="c1">#当前层高度的计算方法模板max     否则就返回正常的高度
</span>        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span><span class="o">!=-</span><span class="mi">1</span>    
            
        
</code></pre></div></div>

<h4 id="二叉树的右视图">二叉树的右视图</h4>

<p>非常不错的一道题，可以用层序遍历，也可以使用递归</p>

<p><img src="/assets/img/leetcode/image-20240808000450321.png" alt="image-20240808000450321" /></p>

<h5 id="层序遍历">层序遍历</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rightSideView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="n">queue</span> <span class="o">=</span> <span class="n">Deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">clevel</span>  <span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span>   <span class="c1">#标准的层序遍历模板
</span>                <span class="n">cnode</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">clevel</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnode</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cnode</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnode</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cnode</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnode</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">clevel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">val</span><span class="p">)</span>    
                
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h5 id="递归">递归</h5>

<p><img src="/assets/img/leetcode/image-20240808000847654.png" alt="image-20240808000847654" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rightSideView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">depth</span><span class="p">):</span>    <span class="c1">#深度优先遍历
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans</span><span class="p">):</span>       <span class="c1">#因为会先到每一层的最右侧，如果别的的节点挡住，那么那个节点一定已经在答案里了
</span>                
                <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>     <span class="c1">#先把右子树遍历完
</span>            <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h4 id="验证二叉树">验证二叉树</h4>

<p>这里就需要实现带区间的树递归参数传递</p>

<p><img src="/assets/img/leetcode/image-20240809125914441.png" alt="image-20240809125914441" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1">#太牛逼了
</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">leftbound</span><span class="p">,</span><span class="n">rightbound</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>    <span class="c1">#空树就是搜索的，没毛病
</span>            <span class="n">v</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span>        
            <span class="n">ok</span> <span class="o">=</span>  <span class="n">v</span><span class="o">&lt;</span><span class="n">rightbound</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&gt;</span><span class="n">leftbound</span>      <span class="c1">#验证一下搜索树的本地性质，现在符合么
</span>            <span class="k">return</span> <span class="n">ok</span> <span class="ow">and</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">leftbound</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">rightbound</span><span class="p">)</span>   <span class="c1">#右子树和左子树也要符合
</span>        <span class="c1">#并且，区间需要变化，这里的区间更新可以详见下面一张图，左子树就更新右边界，右子树就更新左边界
</span>        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span><span class="n">inf</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/img/leetcode/image-20240809130115615.png" alt="image-20240809130115615" /></p>

<p>第二种方法基于，中序遍历二叉搜索树后会得到一个严格递增的数组</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1">#太牛逼了
</span>
        <span class="c1">#还有一种方法们就是中序遍历二叉搜索树会得到一个严格递增的数组
</span>        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> 
            <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h4 id="二叉树的最近公共祖先">二叉树的最近公共祖先</h4>

<p><img src="/assets/img/leetcode/image-20240809153057799.png" alt="image-20240809153057799" /></p>

<p>分类讨论</p>

<p>如果在递归中找到了p或q，就直接返回就行，因为如果另一个在其下方，那么最近公共祖先都是一开始被找到的那个p或q</p>

<p><img src="/assets/img/leetcode/image-20240809153508858.png" alt="image-20240809153508858" /></p>

<p>如果左右子树都找到了，那么返回自身，因为别的情况不可能</p>

<p><img src="/assets/img/leetcode/image-20240809153552904.png" alt="image-20240809153552904" /></p>

<p>如果只有左子树找到了，那么但肯定不在右子树中，因此只需要递归左子树的结果就可以</p>

<p><img src="/assets/img/leetcode/image-20240809153640078.png" alt="image-20240809153640078" /></p>

<p>因此结果为</p>

<p><img src="/assets/img/leetcode/image-20240809153706788.png" alt="image-20240809153706788" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="s">'TreeNode'</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="s">'TreeNode'</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="s">'TreeNode'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">'TreeNode'</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">lca</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span> <span class="ow">or</span> <span class="n">root</span> <span class="o">==</span> <span class="n">p</span> <span class="ow">or</span> <span class="n">root</span> <span class="o">==</span> <span class="n">q</span><span class="p">:</span>   <span class="c1">#这种情况都是返回自身
</span>                <span class="k">return</span> <span class="n">root</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">lca</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>        <span class="c1">#看看能不能找到
</span>            <span class="n">right</span> <span class="o">=</span> <span class="n">lca</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">right</span><span class="p">:</span>           <span class="c1">#都找到了那就ok
</span>                <span class="k">return</span> <span class="n">root</span>
            <span class="k">if</span> <span class="n">left</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">right</span>
        <span class="k">return</span> <span class="n">lca</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="如果这棵树是二叉搜索树">如果这棵树是二叉搜索树</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lca</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span><span class="n">x</span><span class="p">:</span> <span class="c1">#都在左边
</span>                <span class="k">return</span> <span class="n">lca</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span><span class="n">x</span><span class="p">:</span> <span class="c1">#都在右边
</span>                <span class="k">return</span> <span class="n">lca</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">root</span>           <span class="c1">#空节点或者一个在左一个在右就直接返回就可以了
</span>        <span class="k">return</span> <span class="n">lca</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</code></pre></div></div>

<p>二叉树的代码也是同样适用的</p>

<h3 id="bfs-广度优先搜索可以使用基于deque的层序遍历">BFS 广度优先搜索，可以使用基于Deque的层序遍历</h3>

<p><img src="/assets/img/leetcode/image-20240809181906175.png" alt="image-20240809181906175" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">Deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span> <span class="c1">#先传入第一个节点
</span>        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>     <span class="c1">#这里每次到这里就是一层所有的
</span>            <span class="n">layer</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span> <span class="c1">#遍历这一层的每一个
</span>                <span class="n">current</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span> <span class="c1">#从头部开始，这样每一层就是分开的
</span>                <span class="n">layer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">current</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>          <span class="c1">#加入下一层的
</span>                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">current</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>       <span class="c1">#为了返回值的形式
</span>        <span class="k">return</span> <span class="n">res</span>           
</code></pre></div></div>

<h2 id="6回溯">6.回溯</h2>

<h4 id="电话号码的字母组合">电话号码的字母组合</h4>

<p><img src="/assets/img/leetcode/image-20240809185424619.png" alt="image-20240809185424619" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">letterCombinations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">digits</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">digits</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dic</span> <span class="o">=</span><span class="p">{</span>
            <span class="s">"2"</span><span class="p">:</span><span class="s">"abc"</span><span class="p">,</span>
            <span class="s">"3"</span><span class="p">:</span><span class="s">"def"</span><span class="p">,</span>
            <span class="s">"4"</span><span class="p">:</span><span class="s">"ghi"</span><span class="p">,</span>
            <span class="s">"5"</span><span class="p">:</span><span class="s">"jkl"</span><span class="p">,</span>
            <span class="s">"6"</span><span class="p">:</span><span class="s">"mno"</span><span class="p">,</span>
            <span class="s">"7"</span><span class="p">:</span><span class="s">"pqrs"</span><span class="p">,</span>
            <span class="s">"8"</span><span class="p">:</span><span class="s">"tuv"</span><span class="p">,</span>
            <span class="s">"9"</span><span class="p">:</span><span class="s">"wxyz"</span>
        <span class="p">}</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">):</span>     <span class="c1">#这里的index指的是到了这个digits的第几位
</span>                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>     <span class="c1">#这里复杂度是n
</span>                <span class="k">return</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="n">digits</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span>   <span class="c1">#当前位可以选择的字母     这里由于最多可以有4个字母，因此是4^n
</span>            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">current</span><span class="p">:</span>
                <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>
                <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>     <span class="c1">#恢复现场，不然这个path会越来越长
</span>        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,[])</span>
        <span class="k">return</span> <span class="n">res</span>     
    <span class="c1">#时间复杂度O(n*4^n)
</span></code></pre></div></div>

<h3 id="1子集型回溯">1.子集型回溯</h3>

<h4 id="子集">子集</h4>

<p><img src="/assets/img/leetcode/image-20240813173825448.png" alt="image-20240813173825448" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">subsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>           <span class="c1">#这个index可以转化为操作的次数
</span>            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">copy</span><span class="p">())</span>    <span class="c1">#需要copy，不然传入的是一个引用
</span>                <span class="k">return</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>     <span class="c1">#不选
</span>            <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>         <span class="c1">#这里每次操作数+1
</span>            <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>      <span class="c1">#选
</span>            <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>           <span class="c1">#恢复现场
</span>        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,[])</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<p>第二种方法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">subsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>       <span class="c1">#每次必须选一个
</span>            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">copy</span><span class="p">())</span>  <span class="c1">#每次递归都加入一下当前的路径
</span>            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>           <span class="c1">#这就停止了
</span>                <span class="k">return</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span> <span class="c1">#每次在剩下的nums中选择
</span>                <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>  <span class="c1">#这里是i+1,是我们人为定义的顺序
</span>                <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,[])</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h4 id="分割回文串">分割回文串</h4>

<p><img src="/assets/img/leetcode/image-20240813180523648.png" alt="image-20240813180523648" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">copy</span><span class="p">())</span>  <span class="c1">#由于每一个都要出现，因此在最后放入结果
</span>                <span class="k">return</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span> <span class="c1">#j 作为字串的结束部分
</span>                <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>   <span class="c1">#i作为这个字串的结束位置，也就代表了每一个逗号
</span>                <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>       <span class="c1">#简单判断一下，也可以用相向双指针
</span>                    <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>   <span class="c1">#人为规定的顺序
</span>                    <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,[])</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h3 id="2组合型回溯">2.组合型回溯</h3>

<h4 id="-1"><img src="/assets/img/leetcode/image-20240813210758329.png" alt="image-20240813210758329" /></h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>   <span class="c1">#经典开局
</span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>         <span class="c1">#这边可以作为筛选，这里是长度为k的
</span>                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">return</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>        <span class="c1">#在这里使用标准的遍历
</span>                <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>          <span class="c1">#确保选择过的不会再选择
</span>                <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">,[])</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<p><img src="/assets/img/leetcode/image-20240813213803029.png" alt="image-20240813213803029" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">combinationSum3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">target</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>    <span class="c1">#剪枝
</span>                <span class="k">return</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">==</span><span class="n">k</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">==</span><span class="n">n</span><span class="p">:</span>  <span class="c1">#组合问题，一样的，在这里加一个判断
</span>                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">return</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="mi">10</span><span class="p">):</span>
                <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">-</span><span class="n">i</span>          <span class="c1">#每次减少target，如果大了，那就不需要再遍历了
</span>                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">target</span><span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">+</span><span class="n">i</span>      <span class="c1">#恢复现场
</span>                <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">,[],</span><span class="n">n</span><span class="p">)</span>        <span class="c1">#目标是n
</span>        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<p><img src="/assets/img/leetcode/image-20240813214738748.png" alt="image-20240813214738748" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">generateParenthesis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>

        <span class="n">length</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span>   <span class="c1">#总长度
</span>        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">,</span><span class="n">path</span><span class="p">):</span> <span class="c1">#这里记录，已经放了多少个，左括号和右括号各有多少个，当前的括号形态
</span>            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">length</span> <span class="ow">and</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>       <span class="c1">#记录答案的时间，长度够了，并且左右括号相等就可以
</span>                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">left</span><span class="o">&lt;</span><span class="n">n</span><span class="p">:</span>          <span class="c1">#这里最重要的是，左括号可以加到n，而有括号的数量不能大于左括号
</span>                <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"("</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">right</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>
                <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">right</span><span class="o">&lt;</span><span class="n">left</span><span class="p">:</span>  <span class="c1">#因此每次添加了左括号，右括号才有机会补充
</span>                <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">")"</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>
                <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,[])</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h3 id="3排列型回溯">3.排列型回溯</h3>

<h4 id="全排列">全排列</h4>

<p><img src="/assets/img/leetcode/image-20240813220000520.png" alt="image-20240813220000520" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">permute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>   <span class="c1">#经典开局
</span>            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>         <span class="c1">#如果达成，就加入答案
</span>                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">return</span> 
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>         <span class="c1">#这里只需要多判断一步就可以
</span>                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>  <span class="c1">#如果不在就避免了选择重复
</span>                    <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>
                    <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,[])</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<p>时间复杂度为O (n*n!)</p>

<p>n乘以n的阶乘，因为可选的字母是越来越少的，因此树的深度和每个节点的子节点也是越来越少的</p>

<h4 id="全排列2">全排列2</h4>

<p><img src="/assets/img/leetcode/image-20240813222307034.png" alt="image-20240813222307034" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">permuteUnique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pos</span> <span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">pos</span><span class="p">):</span>    <span class="c1">#这里需要额外加入一个位置列表，用于去除已经使用过了的位置的数
</span>            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>     <span class="c1">#去重，因为会有多种相似的路径
</span>                <span class="k">if</span> <span class="n">path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="k">return</span> 
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>        <span class="c1">#这个位置的数字如果没有被使用
</span>                    <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>            <span class="c1">#使用这个位置的数字
</span>                    <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">pos</span><span class="p">)</span>
                    <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
                    <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,[],</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
        
</code></pre></div></div>

<h4 id="n皇后">N皇后</h4>

<p><img src="/assets/img/leetcode/image-20240814122231934.png" alt="image-20240814122231934" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solveNQueens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">hang</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>     <span class="c1">#可以通过四个列表来监控横向竖向斜向
</span>        <span class="n">lie</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> 
        <span class="n">otho</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#-3-2-10123
</span>        <span class="n">etho</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#3210123
</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">reapath</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">addqueen</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>        <span class="c1">#添加一个皇后，并且标注攻击位置
</span>            <span class="n">hang</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">lie</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">otho</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">etho</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">def</span> <span class="nf">removequeen</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>    <span class="c1">#删除皇后，并且清除攻击位置
</span>            <span class="n">hang</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">lie</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">otho</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">etho</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">def</span> <span class="nf">attacked</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>         <span class="c1">#判断一下是否会被攻击
</span>            <span class="k">return</span> <span class="n">hang</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">or</span> <span class="n">lie</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="ow">or</span> <span class="n">otho</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">etho</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">]</span>
        
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">==</span><span class="n">n</span><span class="p">:</span>          <span class="c1">#这里是当y到达底部的时候，结束递归
</span>                <span class="k">nonlocal</span> <span class="n">res</span>        <span class="c1">#这里可以在另一题中使用，用于返回结果的数量
</span>                <span class="n">res</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">reapath</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">copy</span><span class="p">())</span> <span class="c1">#这个是路径
</span>                <span class="k">return</span> 
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>   <span class="c1">#对于每一行的每一个位置
</span>                <span class="k">if</span> <span class="ow">not</span> <span class="n">attacked</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>   <span class="c1">#如果不被攻击就放置，然后递归下一行
</span>                    <span class="n">addqueen</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
                    <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"."</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="s">"Q"</span><span class="o">+</span><span class="s">"."</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>     <span class="c1">#这里可以制作题目要求的格式
</span>                    <span class="n">dfs</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>      <span class="c1">#y进入下一行
</span>                    <span class="n">path</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">removequeen</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,[])</span>    
        <span class="k">print</span><span class="p">(</span><span class="n">reapath</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reapath</span>
    
    <span class="c1">#时间复杂为O(N^2*N!)
</span></code></pre></div></div>

<h2 id="7动态规划">7动态规划</h2>

<h3 id="从记忆化搜索到递推">从记忆化搜索到递推</h3>

<p>所有的DP都可以看作回溯，但是回溯很慢。因此记录回溯的每一步也就变成了DP</p>

<h4 id="打家劫舍">打家劫舍</h4>

<p><img src="/assets/img/leetcode/image-20240814153920958.png" alt="image-20240814153920958" /></p>

<p>可以先用回溯做</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">inf</span>
        <span class="o">@</span><span class="n">cache</span>    <span class="c1">#记忆化，可以加速，但是函数的参数必须都是可以哈希的
</span>        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">current</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">res</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">current</span><span class="p">)</span>   <span class="c1">#每次都更新最大值
</span>            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>   <span class="c1">#由于涉及到index+1和+2，因此遍历边界需要换
</span>                <span class="k">return</span>
            
            <span class="n">a</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">current</span><span class="p">)</span>  <span class="c1">#第一种情况是当前的不选，选下一个，因此index+1可以选
</span>            <span class="n">b</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">current</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>  <span class="c1">#第二种情况是当前的选，然后下一个不可以选，因此index+2，然后current加上当前的钱
</span>            
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>   <span class="c1">#如果不用装饰器，那就自己实现一个
</span>        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">cache</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>         <span class="c1">#本质上也是储存结果
</span>                <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">=</span><span class="n">res</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

</code></pre></div></div>

<p>接下来使用dp，将空间复杂度也优化到O(1)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>   <span class="c1">#用数组记录每一步的最大价值
</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#这个递推非常关键，我们是通过前面的得到后面的
</span>        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="c1">#最后的那个就是答案
</span></code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">0</span>              <span class="c1">#其实一共也就用三个数，因此在数组里面换换就行了
</span>        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">newf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="n">f0</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">f0</span> <span class="o">=</span> <span class="n">f1</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">newf</span>
        <span class="k">return</span> <span class="n">f1</span>
</code></pre></div></div>

<h3 id="背包问题">背包问题</h3>

<h4 id="-2"><img src="/assets/img/leetcode/image-20240814164309595.png" alt="image-20240814164309595" /></h4>

<h4 id="01背包问题">01背包问题</h4>

<p>01背包问题中，每样可以选择装入背包的物品是有限个，并不是无限多个的。</p>

<p>这里给出一个最简单的背包问题</p>

<p>背包的容量为capacity，w数组代表了每一个物品占用的空间，v数组代表了他们的价值</p>

<p>求出背包所能够装的最大价值</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">zeronebag</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>   <span class="c1">#i是指第i个物品，c是指当前还有多少容量
</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>     <span class="c1">#遍历完成就退出
</span>            <span class="k">return</span> <span class="mi">0</span>
       	<span class="k">if</span> <span class="n">c</span><span class="o">&lt;</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>        <span class="c1">#如果剩余容量不够装，那就跳过，返回不装的情况
</span>            <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
       	<span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>    <span class="c1">#如果够，那么可以选或者不选，都递归一下
</span>   	<span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">capacity</span><span class="p">)</span>
    
</code></pre></div></div>

<h5 id="目标和">目标和</h5>

<p><img src="/assets/img/leetcode/image-20240814172211710.png" alt="image-20240814172211710" /></p>

<p>先来一个暴力解法，时间复杂度很高</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findTargetSumWays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">currentsum</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">currentsum</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">currentsum</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="c1">#加或者减  
</span>            <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">currentsum</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="n">dfs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</code></pre></div></div>

<p>也可以使用另一种想法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findTargetSumWays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="c1">#p   选择的加号的数的合
</span>        <span class="c1">#s-p   选择的减号的数的合
</span>        <span class="c1">#p-(s-p) = t       根据题目有
</span>        <span class="c1">#2p = s+t      #化简
</span>        <span class="c1">#p = (s+t)/2       #转化为
</span>        <span class="n">target</span><span class="o">+=</span><span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">target</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span>  <span class="c1">#这里可以提前判断，如果不能被2整除，那就证明永远不可以得到
</span>            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">target</span> <span class="o">//=</span><span class="mi">2</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="o">@</span><span class="n">cache</span>     <span class="c1">#加速，我们python玩家真的太有操作了
</span>        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">current</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">current</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>  <span class="c1">#如果current被减为0那证明正好够，因此返回1，表示找到了一个可以使用的结果
</span>            <span class="k">if</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>       <span class="c1">#选不了，太大了
</span>                <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">current</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">current</span><span class="p">)</span> <span class="o">+</span> <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">current</span><span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>    <span class="c1">#选或不选，相加是因为要返回结果数量
</span>        
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">target</span><span class="p">)</span>
</code></pre></div></div>

<p>改成递推</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findTargetSumWays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">target</span><span class="o">+=</span><span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">target</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">target</span> <span class="o">//=</span><span class="mi">2</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">target</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="c1">#这里0-target一共有target+1个值，后面也是一样
</span>        <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span> 
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">target</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>   <span class="c1">#这个数没选，target也没变
</span>                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="o">-</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>  <span class="c1">#所有的组合加起来
</span>        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)][</span><span class="n">target</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1"># 计算数组的总和减去目标值的绝对值，并确定转换成的背包问题的容量
</span>        <span class="n">total_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">total_sum</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">half_sum</span> <span class="o">=</span> <span class="n">s</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># 背包容量
</span>
        <span class="n">num_items</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="c1"># 初始化动态规划表格，dp[i][j]表示前i个物品中，能够装满容量为j的背包的方案数
</span>        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">half_sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_items</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 初始条件：不选择任何物品，装满容量为0的背包有1种方式
</span>
        <span class="c1"># 遍历每个物品
</span>        <span class="k">for</span> <span class="n">item_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_items</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># 遍历每个可能的容量
</span>            <span class="k">for</span> <span class="n">capacity</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">half_sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">capacity</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">item_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">item_index</span><span class="p">][</span><span class="n">capacity</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">item_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">capacity</span><span class="p">]</span>  <span class="c1"># 只能不选当前物品
</span>                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">item_index</span><span class="p">][</span><span class="n">capacity</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">item_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">capacity</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">item_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">item_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>  <span class="c1"># 不选当前物品 + 选当前物品
</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">num_items</span><span class="p">][</span><span class="n">half_sum</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="完全背包问题">完全背包问题</h4>

<p><img src="/assets/img/leetcode/image-20240814180543143.png" alt="image-20240814180543143" /></p>

<h5 id="零钱兑换">零钱兑换</h5>

<p><img src="/assets/img/leetcode/image-20240814192943190.png" alt="image-20240814192943190" /></p>

<p>首先是最蠢的办法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">coinChange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">inf</span>
        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">still</span><span class="p">,</span><span class="n">coinn</span><span class="p">):</span>         <span class="c1">#still就是当前还需要选择多少钱  index是当前在哪种硬币上纠结呢
</span>            <span class="k">if</span> <span class="n">still</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>    <span class="c1">#coinn就是当前选择了多少个硬币
</span>                <span class="k">nonlocal</span> <span class="n">res</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">coinn</span><span class="p">)</span> 
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">still</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">still</span><span class="o">-</span><span class="n">coins</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">coinn</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#这里和01背包问题不一样的是，在选择后，index不需要-1，你可以继续选，如果不选，再-1
</span>            <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">still</span><span class="p">,</span><span class="n">coinn</span><span class="p">)</span>
        <span class="n">dfs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">amount</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span> <span class="k">if</span> <span class="n">res</span><span class="o">!=</span><span class="n">inf</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>  

</code></pre></div></div>

<p>再来一种直接返回的</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">coinChange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span>
        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">c</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">inf</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="n">coins</span><span class="p">[</span><span class="n">index</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dfs</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">))</span>  <span class="c1">#这边返回值直接就是硬币个数，因此需要+1
</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span> <span class="k">if</span> <span class="n">res</span><span class="o">!=</span><span class="n">inf</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>递推写法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">coinChange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">inf</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="c1">#这边都是要+1的因为总的要迭代的对象个数是这么多
</span>        <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c1">#第一个位置要初始化
</span>        <span class="k">for</span> <span class="n">cindex</span><span class="p">,</span><span class="n">cvalue</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coins</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">am</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">am</span> <span class="o">&lt;</span> <span class="n">cvalue</span><span class="p">:</span>           <span class="c1">#如果不够
</span>                    <span class="n">f</span><span class="p">[</span><span class="n">cindex</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">am</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">cindex</span><span class="p">][</span><span class="n">am</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>                     <span class="c1">#其他情况就是选或者不选
</span>                    <span class="n">f</span><span class="p">[</span><span class="n">cindex</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">am</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">cindex</span><span class="p">][</span><span class="n">am</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">cindex</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">am</span><span class="o">-</span><span class="n">cvalue</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c1">#这后面一个+1就对应了完全背包的性质
</span>        <span class="n">res</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">amount</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="n">inf</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<h3 id="线性dp">线性DP</h3>

<h4 id="最长公共子序列">最长公共子序列</h4>

<p><img src="/assets/img/leetcode/image-20240814204448750.png" alt="image-20240814204448750" /></p>

<p>先来一个回溯解法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestCommonSubsequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">text2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text1</span><span class="p">)</span>     <span class="c1">#这里是长度
</span>        <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span>
        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>    <span class="c1">#如果index到了，那就返回，表明没有了
</span>                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">text1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">text2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>     <span class="c1">#如果两个字母相等，那就可以都选
</span>                <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1">#如果不相等，那么只选一个
</span>        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">n1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
   <span class="c1">#时间复杂度O(n1*n2)
</span></code></pre></div></div>

<p>递推写法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestCommonSubsequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">text2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text1</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">text1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">text2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="编辑距离">编辑距离</h4>

<p><img src="/assets/img/leetcode/image-20240815133917223.png" alt="image-20240815133917223" /></p>

<p><img src="/assets/img/leetcode/image-20240815140304897.png" alt="image-20240815140304897" /></p>

<p>首先是回溯写法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minDistance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">word2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">word1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">word2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word1</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word2</span><span class="p">)</span>
        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>      
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span>        <span class="c1">#如果有任何一个字符串没了，那么就是要删掉另一个的所有，需要这么多操作
</span>            <span class="k">if</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">word1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">word2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>       <span class="c1">#如果这两个字母一样，那就不需要操作，直接返回下一部分
</span>            <span class="k">else</span><span class="p">:</span>           <span class="c1">#这里是关键，这三个操作，插入，删除，替换，可以抽象为
</span>                            <span class="c1">#再word1中插入，也就是在word2中删除一个
</span>                    		<span class="c1">#再word1中删除，那就正常删除一个
</span>                        	<span class="c1">#替换，那就意味着两边都减少一个
</span>                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>递推</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minDistance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">word2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word1</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word2</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1">#边界条件
</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>  <span class="c1">#边界条件
</span>            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">word2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">word1</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span>    <span class="c1">#等比翻译
</span>                    
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="最长递增子序列">最长递增子序列</h4>

<p><img src="/assets/img/leetcode/image-20240815161039868.png" alt="image-20240815161039868" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lengthOfLIS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>  <span class="c1">#i表示当前第i个数字作为整个串的末尾
</span>            <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="c1">#遍历前面每一个数
</span>                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>   <span class="c1">#如果遇到小的，那就从那边开始
</span>                    <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c1">#枚举每一种末尾         O(N^2)
</span>            <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lengthOfLIS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="c1">#dfs改成f数组，递归改成循环
</span>        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>     
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>     
</code></pre></div></div>

<h3 id="状态机dp">状态机DP</h3>

<p><img src="/assets/img/leetcode/image-20240815204004197.png" alt="image-20240815204004197" /></p>

<h4 id="买卖股票的最佳时机不限制交易次数">买卖股票的最佳时机，不限制交易次数</h4>

<p><img src="/assets/img/leetcode/image-20240816193722387.png" alt="image-20240816193722387" /></p>

<p>投机取巧的方法</p>

<p>做T，短线交易</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">duanxian</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>    <span class="c1">#能挣钱么
</span>                <span class="n">duanxian</span><span class="o">+=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1">#那就挣了
</span>        <span class="k">return</span> <span class="n">duanxian</span>
</code></pre></div></div>

<p>回溯</p>

<p><img src="/assets/img/leetcode/image-20240816202808795.png" alt="image-20240816202808795" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
        <span class="c1">#倒着思考
</span>        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">hold</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1">#当i&lt;0天，由于一开始不持有股票
</span>                <span class="k">return</span> <span class="o">-</span><span class="n">inf</span> <span class="k">if</span> <span class="n">hold</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">hold</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">True</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1">#           什么也不做     卖出手里的股票
</span>            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">False</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span><span class="o">+</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1">#买入股票 或者还是什么都不做
</span>        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>

</code></pre></div></div>

<p>翻译成递推</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">inf</span> <span class="c1">#我们需要多一个状态用于存储，说明第一天是不可能有股票的
</span>        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prices</span><span class="p">):</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">p</span><span class="p">)</span>  <span class="c1">#后面的全部都+1
</span>            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="如果有冷冻期呢">如果有冷冻期呢</h4>

<p><img src="/assets/img/leetcode/image-20240816211415201.png" alt="image-20240816211415201" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
        <span class="c1">#倒着思考
</span>        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">hold</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1">#当i&lt;0天，由于一开始不持有股票
</span>                <span class="k">return</span> <span class="o">-</span><span class="n">inf</span> <span class="k">if</span> <span class="n">hold</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">hold</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">True</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1">#这边由于有冷冻期，因此需要变成i-2，我只能卖前天买的
</span>                <span class="c1">#           什么也不做     卖出手里的股票
</span>            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">False</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span><span class="o">+</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1">#买入股票 或者还是什么都不做
</span>        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="如果有交易次数限制呢">如果有交易次数限制呢</h4>

<p><img src="/assets/img/leetcode/image-20240816211902082.png" alt="image-20240816211902082" /></p>

<p><img src="/assets/img/leetcode/image-20240816211949383.png" alt="image-20240816211949383" /></p>

<p>这里就需要添加一个参数，表示，到i天结束时，完成了最多j笔交易</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
        <span class="c1">#倒着思考
</span>        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">hold</span><span class="p">):</span> <span class="c1">#j代表，到i天结束时，完成了最多j笔交易
</span>            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">inf</span>       <span class="c1">#如果j&lt;0 那就证明这个交易是不合法的
</span>            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1">#当i&lt;0天，由于一开始不持有股票
</span>                <span class="k">return</span> <span class="o">-</span><span class="n">inf</span> <span class="k">if</span> <span class="n">hold</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">hold</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="bp">True</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1">#           什么也不做     卖出手里的股票
</span>            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="bp">False</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span><span class="o">+</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1">#买入股票 或者还是什么都不做
</span>                                             <span class="c1">#这里j-1意味着减少了一次交易
</span>        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div>

<p>递推</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
		<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
         <span class="n">f</span> <span class="o">=</span> <span class="p">[[[</span><span class="o">-</span><span class="n">inf</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1">#三维数组
</span>         <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
             <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prices</span><span class="p">):</span>
             <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                 <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">p</span><span class="p">)</span>
                 <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">)</span>
         <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="恰好和至少">恰好和至少</h4>

<p><img src="/assets/img/leetcode/image-20240816213526221.png" alt="image-20240816213526221" /></p>

<h3 id="区间dp">区间DP</h3>

<h4 id="最长回文子序列">最长回文子序列</h4>

<p><img src="/assets/img/leetcode/image-20240816215411899.png" alt="image-20240816215411899" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestPalindromeSubseq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>    <span class="c1">#这是一个空串
</span>            <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">:</span>         <span class="c1"># 长度为1的串就是回文，所以直接返回1就可以了
</span>                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span>       <span class="c1">#如果两边都相等，那么久都选，然后结果+2
</span>            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1">#要不然就选左边或者选右边
</span>        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestPalindromeSubseq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>    <span class="c1">#倒序遍历
</span>            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>  <span class="c1">#正序遍历
</span>                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="多边形三角剖分的最低得分">多边形三角剖分的最低得分</h4>

<p><img src="/assets/img/leetcode/image-20240818165035073.png" alt="image-20240818165035073" /></p>

<p><img src="/assets/img/leetcode/image-20240818165050375.png" alt="image-20240818165050375" /></p>

<p><img src="/assets/img/leetcode/image-20240818165106360.png" alt="image-20240818165106360" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minScoreTriangulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span><span class="n">j</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>   <span class="c1">#不存在三角形
</span>            <span class="n">res</span> <span class="o">=</span> <span class="n">inf</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">dfs</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="c1">#左边形状，本三角形和右边形状
</span>            <span class="k">return</span> <span class="n">res</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

</code></pre></div></div>

<h3 id="树形dp">树形DP</h3>

<h4 id="二叉树的直径">二叉树的直径</h4>

<p><img src="/assets/img/leetcode/image-20240818173714786.png" alt="image-20240818173714786" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">diameterOfBinaryTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

    <span class="c1">#当前链的长度等于左子树的最长加右子树的最长+2
</span>        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="o">@</span><span class="n">cache</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">lenl</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>    <span class="c1">#左子树的最大高度
</span>            <span class="n">lenr</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>     <span class="c1">#右子树的最大高度
</span>            <span class="k">nonlocal</span> <span class="n">res</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">lenl</span><span class="o">+</span><span class="n">lenr</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>         <span class="c1">#结果在这里更新
</span>            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">lenl</span><span class="p">,</span><span class="n">lenr</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>      <span class="c1">#这边可以保证返回最大高度
</span>        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    
   <span class="c1"># O(N)
</span></code></pre></div></div>

<h4 id="二叉树中的最大路径和">二叉树中的最大路径和</h4>

<p><img src="/assets/img/leetcode/image-20240818180927770.png" alt="image-20240818180927770" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxPathSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">inf</span>  <span class="c1">#取最大那就用-inf
</span>        
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">sumnodeleft</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>   <span class="c1">#左子树的最大和
</span>            <span class="n">sumnoderight</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1">#右子树的最大和
</span>            <span class="k">nonlocal</span> <span class="n">res</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">sumnodeleft</span><span class="o">+</span><span class="n">sumnoderight</span><span class="o">+</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>       <span class="c1">#左子树的最大和+右子树的最大和
</span>            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">sumnodeleft</span><span class="p">,</span><span class="n">sumnoderight</span><span class="p">)</span><span class="o">+</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>    <span class="c1">#保证返回左子树或者右子树的最大值加上当前节点值
</span>            <span class="c1">#这边和0比大小很关键，因为如果算出一个部分是负数，那还不如不选，因此要和0比大小，这里的0不是指结点的值为0而是指子树的整体大小为0
</span>        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

</code></pre></div></div>

<h4 id="一般树中相邻字符不同的最长路径">一般树中，相邻字符不同的最长路径</h4>

<p><img src="/assets/img/leetcode/image-20240818184335866.png" alt="image-20240818184335866" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span>  <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="c1">#这边也可以用哈希表
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>        <span class="c1">#把每一个位置的子节点做好
</span>            <span class="n">g</span><span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">ans</span>
            <span class="n">lenofx</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 初始化变量lenofx，表示从当前节点x向下延伸的最长路径
</span>            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>       <span class="c1">#对于每一个节点的子节点
</span>                <span class="n">lenofy</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>    <span class="c1"># 递归调用dfs计算子节点y的最长路径，并加1表示包括当前节点y
</span>                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">!=</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>    <span class="c1"># 只有当子节点y的字符和当前节点x的字符不同时，才考虑更新路径
</span>                    <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span><span class="n">lenofx</span><span class="o">+</span><span class="n">lenofy</span><span class="p">)</span>   <span class="c1"># 更新全局的最长路径长度ans
</span>                    <span class="n">lenofx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lenofx</span><span class="p">,</span><span class="n">lenofy</span><span class="p">)</span>    <span class="c1"># 更新当前节点x的最长路径长度
</span>            <span class="k">return</span> <span class="n">lenofx</span>     <span class="c1"># 返回从当前节点x向下延伸的最长路径
</span>        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">+</span><span class="mi">1</span>
</code></pre></div></div>

<h4 id="打家劫舍3">打家劫舍3</h4>

<p><img src="/assets/img/leetcode/image-20240818190212782.png" alt="image-20240818190212782" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 这个变量`res`其实没有用到，可以移除
</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>  <span class="c1"># 如果当前节点为空，返回(0, 0)，表示两种情况都为0
</span>            
            <span class="c1"># 递归计算左子树的两种情况的收益
</span>            <span class="n">lrob</span><span class="p">,</span> <span class="n">lnotrob</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="c1"># 递归计算右子树的两种情况的收益
</span>            <span class="n">rrob</span><span class="p">,</span> <span class="n">rnotrob</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
            <span class="c1"># 抢劫当前节点的收益：当前节点的值 + 左右子树不能抢劫子节点的最大收益
</span>            <span class="n">rob</span> <span class="o">=</span> <span class="n">lnotrob</span> <span class="o">+</span> <span class="n">rnotrob</span> <span class="o">+</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
            <span class="c1"># 不抢劫当前节点的收益：左右子树的两种情况的最大值之和
</span>            <span class="n">notrob</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lrob</span><span class="p">,</span> <span class="n">lnotrob</span><span class="p">)</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">rrob</span><span class="p">,</span> <span class="n">rnotrob</span><span class="p">)</span> <span class="c1">#左右子树可以随便选，因为我们选择了他
</span>            
            <span class="c1"># 返回当前节点的两种情况的收益
</span>            <span class="k">return</span> <span class="n">rob</span><span class="p">,</span> <span class="n">notrob</span>

        <span class="c1"># 对根节点调用dfs，并返回两种情况的最大值
</span>        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</code></pre></div></div>

<h4 id="监控二叉树">监控二叉树</h4>

<p><img src="/assets/img/leetcode/image-20240818193728388.png" alt="image-20240818193728388" /></p>

<p>如果根节点不装，那么至少他有一个子节点要装</p>

<p><img src="/assets/img/leetcode/image-20240818194103264.png" alt="image-20240818194103264" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minCameraCover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">inf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>  <span class="c1"># 空节点的三种状态：不能安装摄像头，0个摄像头即可满足被监控到，不用被监控
</span>            
            <span class="n">l_choose</span><span class="p">,</span> <span class="n">l_by_fa</span><span class="p">,</span> <span class="n">l_by_children</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>  <span class="c1"># 处理左子节点
</span>            <span class="n">r_choose</span><span class="p">,</span> <span class="n">r_by_fa</span><span class="p">,</span> <span class="n">r_by_children</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>  <span class="c1"># 处理右子节点
</span>            
            <span class="c1"># 当前节点选择放置摄像头的情况
</span>            <span class="n">choose</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l_choose</span><span class="p">,</span> <span class="n">l_by_fa</span><span class="p">)</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">r_choose</span><span class="p">,</span> <span class="n">r_by_fa</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            
            <span class="c1"># 当前节点不放摄像头，而由父节点来监控的情况
</span>            <span class="n">by_fa</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l_choose</span><span class="p">,</span> <span class="n">l_by_children</span><span class="p">)</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">r_choose</span><span class="p">,</span> <span class="n">r_by_children</span><span class="p">)</span>
            
            <span class="c1"># 当前节点不放摄像头，由子节点来监控的情况
</span>            <span class="n">by_children</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l_choose</span> <span class="o">+</span> <span class="n">r_by_children</span><span class="p">,</span> <span class="n">l_by_children</span> <span class="o">+</span> <span class="n">r_choose</span><span class="p">,</span> <span class="n">l_choose</span> <span class="o">+</span> <span class="n">r_choose</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">choose</span><span class="p">,</span> <span class="n">by_fa</span><span class="p">,</span> <span class="n">by_children</span>
        
        <span class="n">choose</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">by_children</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>  <span class="c1"># 根节点没有父节点，所以只考虑选择摄像头或由子节点监控
</span>        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">choose</span><span class="p">,</span> <span class="n">by_children</span><span class="p">)</span>

</code></pre></div></div>

<h3 id="迷宫dp">迷宫DP</h3>

<p>地下城游戏</p>

<p><img src="/assets/img/leetcode/image-20240818123931311.png" alt="image-20240818123931311" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">calculateMinimumHP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dungeon</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">BIG</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">BIG</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">minn</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">minn</span> <span class="o">-</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<p>###</p>

<h2 id="单调栈">单调栈</h2>

<h4 id="每日温度">每日温度</h4>

<p><img src="/assets/img/leetcode/image-20240818214621097.png" alt="image-20240818214621097" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">dailyTemperatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temperatures</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1">#O(min(n,U))    U = temperatures[MAX] - temperatures[MIN]+1
</span>        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">temperatures</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1">#倒着遍历
</span>            <span class="n">t</span> <span class="o">=</span> <span class="n">temperatures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>       <span class="c1">#当前的温度
</span>            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">temperatures</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">&lt;=</span><span class="n">t</span><span class="p">:</span> <span class="c1">#对于栈中小于自身的，全部pop掉，因为他们没用
</span>                                                     <span class="c1">#为什么呢，因为之后遍历到的，最高肯定不会是那些比自己小的，而是自己
</span>                <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">stack</span><span class="p">:</span> <span class="c1">#如果栈不为空，那么栈顶数据比自己大，可以作为答案
</span>                <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">i</span> <span class="c1">#索引，距离当前有多少天
</span>            <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>    <span class="c1">#每次都会把当前索引放进去
</span>        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h4 id="接雨水-1">接雨水</h4>

<p><img src="/assets/img/leetcode/image-20240819145959426.png" alt="image-20240819145959426" /></p>

<p>单调栈做法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">trap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 用于存储最后的接雨水总量
</span>        <span class="n">st</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 这是一个栈，用于存储柱子的索引
</span>        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
            <span class="c1"># 栈非空且当前高度大于或等于栈顶元素的高度时，说明可以形成凹槽
</span>            <span class="k">while</span> <span class="n">st</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">&gt;=</span> <span class="n">height</span><span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">bottom_h</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">()]</span>  <span class="c1"># 弹出栈顶元素，表示凹槽的底部高度
</span>                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>  <span class="c1"># 如果栈为空，说明没有左边的边界，不能形成凹槽，跳出循环
</span>                
                <span class="n">left</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># 栈顶元素弹出后，现在的栈顶就是左边界
</span>                <span class="n">dh</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="n">bottom_h</span>  <span class="c1"># 计算水的高度，取左边界和当前高度的较小值减去底部高度
</span>                
                <span class="c1"># 接水量为水的高度乘以宽度，宽度为 `i - left - 1`
</span>                <span class="n">ans</span> <span class="o">+=</span> <span class="n">dh</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="n">st</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># 将当前柱子的索引入栈
</span>        
        <span class="k">return</span> <span class="n">ans</span>  <span class="c1"># 返回最终接住的雨水总量
</span></code></pre></div></div>

<p>最大前缀做法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">trap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 初始化前缀和后缀数组
</span>        <span class="n">prefix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
        <span class="n">postfix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
        <span class="c1"># 计算每个位置的前缀最大高度
</span>        <span class="n">currentheiget</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">currentheiget</span><span class="p">:</span>
                <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentheiget</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">currentheiget</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentheiget</span>
        <span class="c1"># 计算每个位置的后缀最大高度
</span>        <span class="n">currentheiget</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">currentheiget</span><span class="p">:</span>
                <span class="n">postfix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentheiget</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">currentheiget</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">postfix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentheiget</span>
        <span class="c1"># 计算能够存储的水量
</span>        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)):</span>
            <span class="n">realh</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">postfix</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">realh</span>

        <span class="k">return</span> <span class="n">res</span>

</code></pre></div></div>

<h2 id="单调队列">单调队列</h2>

<h4 id="滑动窗口最大值">滑动窗口最大值</h4>

<p><img src="/assets/img/leetcode/image-20240819154650874.png" alt="image-20240819154650874" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxSlidingWindow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 用来存放结果，即每个滑动窗口的最大值
</span>        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>  <span class="c1"># 双端队列，存储的是元素的索引
</span>        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="c1"># 1. 入窗口：保证队列中的元素按照从大到小的顺序排列
</span>            <span class="k">while</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># 队列中如果存在比当前元素小的元素，它们永远不可能成为最大值，移除它们
</span>            <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># 将当前元素的索引加入到队列中
</span>            
            <span class="c1"># 2. 出窗口：检查队首元素是否还在当前窗口中，如果不在，则移出队列
</span>            <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>  <span class="c1"># 队首元素已经不在窗口范围内了，移出队列
</span>            
            <span class="c1"># 3. 记录答案：当遍历到第 `k` 个元素时开始记录窗口最大值
</span>            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>  <span class="c1"># 队首元素就是当前窗口的最大值
</span>        
        <span class="k">return</span> <span class="n">ans</span>  <span class="c1"># 返回所有滑动窗口的最大值
</span>
</code></pre></div></div>

:ET